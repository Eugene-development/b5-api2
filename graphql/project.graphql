enum ProjectStatus {
    ACTIVE @enum(value: "active")
    COMPLETED @enum(value: "completed")
    CANCELLED @enum(value: "cancelled")
}

enum AgentRateType {
    PERCENTAGE @enum(value: "percentage")
    FIXED @enum(value: "fixed")
}

type ProjectStatusType {
    id: ID!
    value: String!
    slug: String!
    description: String
    color: String
    icon: String
    sort_order: Int
    is_default: Boolean!
    is_active: Boolean!
    created_at: DateTime!
    updated_at: DateTime!
}

type Project {
    id: ID!
    value: String
    user_id: ID
    client_id: ID
    status_id: ID
    agent: User @belongsTo(foreignKey: "user_id")
    client: Client @belongsTo(foreignKey: "client_id")
    status: ProjectStatusType @belongsTo(foreignKey: "status_id")
    users: [User!] @belongsToMany(relation: "users")
    contracts: [Contract!] @hasMany
    region: String
    description: String
    is_active: Boolean
    is_incognito: Boolean
    contract_name: String
    contract_number: String
    contract_date: Date
    contract_amount: Float
    agent_percentage: Float
    planned_completion_date: Date
    phones: [ProjectPhone!] @hasMany
    sketches: [ProjectSketch!] @hasMany
    offers: [ProjectOffer!] @hasMany
    created_at: DateTime!
    updated_at: DateTime!
}

type ProjectPhone {
    id: ID!
    project_id: ID!
    value: String!
    contact_person: String
    is_primary: Boolean
    created_at: DateTime!
    updated_at: DateTime!
}

input CreateProjectInput {
    value: String!
    user_id: ID
    client_id: ID
    region: String
    description: String
    is_active: Boolean = true
    is_incognito: Boolean = false
    contract_name: String
    contract_date: Date
    contract_amount: Float
    agent_percentage: Float
    planned_completion_date: Date
}

input UpdateProjectInput {
    id: ID!
    value: String
    user_id: ID
    client_id: ID
    status_id: ID
    region: String
    description: String
    is_active: Boolean
    is_incognito: Boolean
    contract_name: String
    contract_date: Date
    contract_amount: Float
    agent_percentage: Float
    planned_completion_date: Date
}

extend type Query {
    "Get all projects"
    projects: [Project!]! @paginate

    "Get a single project by ID"
    project(id: ID! @whereKey): Project @find

    "Get projects by status"
    projectsByStatus(status: ProjectStatus! @where): [Project!]! @paginate

    "Get projects by agent"
    # projectsByAgent(user_id: ID! @where): [Project!]! @paginate
    projectsByAgent(user_id: ID! @where): [Project!]! @all

    "Get all project statuses"
    projectStatuses: [ProjectStatusType!]! @all(model: "App\\Models\\ProjectStatus")

    "Get all clients"
    clients: [Client!]! @all(model: "App\\Models\\Client")

    "Get a single client by ID"
    client(id: ID! @whereKey): Client @find(model: "App\\Models\\Client")
}

type ProjectUser {
    id: ID!
    user_id: ID!
    project_id: ID!
    created_at: DateTime!
    updated_at: DateTime!
}

extend type Mutation {
    "Create a new project"
    createProject(input: CreateProjectInput! @spread): Project!

    "Update an existing project"
    updateProject(input: UpdateProjectInput! @spread): Project! @update

    "Delete a project"
    deleteProject(id: ID! @whereKey): Project! @delete

    "Accept a project (link user to project)"
    acceptProject(projectId: ID!, userId: ID!, statusId: ID): ProjectUser! @field(resolver: "App\\GraphQL\\Mutations\\AcceptProject")
}

scalar DateTime
    @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

type Client {
    id: ID!
    name: String!
    birthday: Date
    ban: Boolean!
    status_id: ID
    projects: [Project!] @hasMany
    phones: [ClientPhone!] @hasMany
    created_at: DateTime!
    updated_at: DateTime!
}

type ClientPhone {
    id: ID!
    client_id: ID!
    value: String!
    is_primary: Boolean
    created_at: DateTime!
    updated_at: DateTime!
}
